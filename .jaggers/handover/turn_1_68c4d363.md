I will begin by exploring the existing documentation and session management files to understand the current Jaggers orchestration architecture.
I will search for any existing references to "session pinning" or "UUID" in the codebase to see if there are already some preliminary designs or discussions on this topic.
I will use `grep_search` to find any mentions of "session pinning" or "UUID" and `glob` to locate files that might be related to session management or orchestration.
I will read `.jaggers/sessions.json` and the handover files, and I'll also carefully examine `skills/orchestrating-agents/SKILL.md` to understand the current session handling logic.
I'll examine `skills/orchestrating-agents/references/workflows.md` to understand the current workflow steps, then I'll finalize my proposal for session pinning, including the transition to contextual sessions, the use of a Jaggers Session Registry, UUID-based pinning, and task ID propagation.
To handle session pinning for multi-turn agent workflows in the Jaggers orchestration ecosystem, I propose a **Deterministic Contextual Pinning (DCP)** architecture. This solution replaces the fragile "global latest" state with explicit, task-specific session tracking.

### 1. The Core Architecture: Jaggers Session Registry (JSR)
Jaggers must move away from relying on `-r latest` (Gemini) or `-c` (Qwen), which are easily corrupted by parallel commands. Instead, the ecosystem should utilize the existing `.jaggers/sessions.json` as a **Project-Level Session Registry**.

#### Proposed Registry Schema Enhancement
Each Jaggers Task ID should map to an `agents` object containing pinned session identifiers for every sub-agent involved.

```json
{
  "task_ba92bb75": {
    "workflow": "collaborative",
    "status": "in_progress",
    "agents": {
      "gemini": {
        "session_id": "1b7837eb-ab75-4ee1-a00e-7edf935559c5",
        "turns_completed": 3
      },
      "qwen": {
        "session_id": "qwen_2026_02_18_abc123",
        "turns_completed": 1
      }
    }
  }
}
```

### 2. The Pinning Protocol: UUID-based Resumption
The orchestration engine should capture the unique Session ID during the initial "Handshake" turn and use it for all subsequent "Iterative" turns.

#### Protocol Steps:
1.  **Initial Handshake (Turn 1)**:
    - Execute: `gemini -p "Draft the design..."`
    - Jaggers reads the `GEMINI_SESSION_ID` from the environment or tool output.
    - Save this ID to the JSR under `agents.gemini.session_id`.
2.  **Iterative Resumption (Turn N)**:
    - Instead of `-r latest`, Jaggers retrieves the pinned ID from the JSR.
    - Execute: `gemini -r 1b7837eb-ab75-4ee1-a00e-7edf935559c5 -p "Address Agent B's critique..."`

### 3. Solution Components

#### A. Task ID Propagation via Environment
To ensure hooks and scripts can access the correct context, Jaggers should export a `JAGGERS_TASK_ID` environment variable before any shell command execution.
- **Workflow**: `export JAGGERS_TASK_ID=ba92bb75 && gemini -p "..."`

#### B. Dynamic Command Rewriting (Hook)
Implement a `BeforeAgent` hook that automatically replaces `latest` with the correct pinned ID if it detects an active Jaggers task.
- **Input**: `gemini -r latest -p "..."`
- **Output**: `gemini -r <PINNED_UUID> -p "..."`

#### C. Cross-Agent "Handover" Artifacts
Use the `.jaggers/handover/` directory to store "Artifact Capsules"â€”files containing the output of one agent plus the metadata (Task ID, Source Agent, Session ID). This allows the primary agent to "resume" any agent's context by simply reading the capsule and the registry.

### 4. Implementation Plan
1.  **Update `AgentContext` Hook**: Modify `hooks/agent_context.py` to automatically update `.jaggers/sessions.json` with the current `GEMINI_SESSION_ID` after every execution.
2.  **Refactor Workflows**: Update `skills/orchestrating-agents/references/workflows.md` to mandate the use of explicit session IDs in the "Action" column.
3.  **Command-Line Flag Enforcement**: Update the `orchestrate` skill logic to generate and pass explicit `-r <id>` flags based on registry lookups.

### Summary of Benefits
- **Parallel Safety**: Multiple design sessions or audits can run simultaneously without "Session Bleed."
- **Persistence**: Workflows can be paused and resumed across different days or machine reboots by reading the registry.
- **Deterministic Auditing**: Every turn in a Jaggers workflow is tied to a specific, immutable agent session ID.
